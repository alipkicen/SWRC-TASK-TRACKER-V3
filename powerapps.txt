1) Power BI: connect & model

Get Data → MySQL database

Server: <your_mysql_host>

Database: <your_db_name>

Choose Import (fast for small/medium data) or DirectQuery (live, but some features limited).

Select objects: tick v_requests_for_bi, and (optional) lots, sampling_lots, request_status_history.

Relationships (Model view):

lots.request_id → v_requests_for_bi.id (Many-to-One, single direction)

sampling_lots.request_id → v_requests_for_bi.id

request_status_history.request_id → v_requests_for_bi.id

Data types (right pane):

Set created_at, started_at, completed_at, date_of_request, qr_date to Date/Time.

cycle_time_hours is Decimal Number.

Measures (DAX) – create in v_requests_for_bi table:

Requests = COUNTROWS('v_requests_for_bi')
In Progress = CALCULATE([Requests], 'v_requests_for_bi'[status] = "In Progress")
Completed = CALCULATE([Requests], 'v_requests_for_bi'[status] = "Completed")
Issue = CALCULATE([Requests], 'v_requests_for_bi'[status] = "Issue")
Completed % = DIVIDE([Completed], [Requests], 0)
Avg Cycle (hrs) = AVERAGE('v_requests_for_bi'[cycle_time_hours])


Core visuals:

Slicer: request_type (lets you view each type separately).

Cards: Requests, In Progress, Completed, Issue, Completed %, Avg Cycle (hrs).

Bar/Column: Requests by request_type and by status.

Table (detail): id, request_type, status, executor, created_at, started_at, completed_at, lots_count, sampling_lots_count.

Write-back for status (optional):

Add a Power Apps visual; bind id, status, executor.

In the app, call your API PATCH /api/requests/:id/status with { status, executor, note }.

On success, refresh (DirectQuery refreshes automatically; Import → click Refresh).

2) Tableau: connect & model

Connect → MySQL. Choose the same database, drag v_requests_for_bi to the canvas.

Drag lots and sampling_lots next to it and Relate on request_id = id (left table is v_requests_for_bi).

On Data Source page, confirm data types (Date/Time for datetime fields).

Sheets:

Filters: request_type

KPI tiles (use Text marks or Dashboard objects) from quick table calcs:

Requests = COUNT([id])

Completed = COUNT(IF [status]="Completed" THEN [id] END)

Completed % = COUNT(IF [status]="Completed" THEN [id] END) / COUNT([id])

Avg Cycle (hrs) = AVG([cycle_time_hours])

Bars: COUNT([id]) by status; another by request_type.

Detail table: show id, status, executor, created_at, completed_at, lots_count, sampling_lots_count.

Write-back (optional): use a Tableau Extension (Write-Back/Parameter Actions) or a simple dashboard button that opens a small web form calling your PATCH API.

3) Suggested layout (works in both tools)

Header KPIs: Requests | In Progress | Completed | Issue | Completed % | Avg Cycle (hrs)

Left column: bar chart Requests by request_type; stacked bar Status by request_type.

Right column: trend line Requests over time (use created_at by month); table of latest requests.

Global slicers: request_type, task_priority, status, date range (created_at).

4) Handy checks & tips

Sanity check SQL (run in MySQL to preview the view data):

SELECT * FROM v_requests_for_bi ORDER BY created_at DESC LIMIT 20;
SELECT request_type, status, COUNT(*) FROM v_requests_for_bi GROUP BY 1,2;


Timezone note: your DB DATETIME has no timezone. If your server/app is using UTC but you want Malaysia time in visuals, create a calculated field with +8 hours (or do it in your ETL).

Performance: for large data, prefer DirectQuery/Live with indexes on:

requests(id, request_type, status, created_at, completed_at)

lots(request_id) and sampling_lots(request_id)

That’s it—connect to v_requests_for_bi for easy KPIs and use lots/sampling_lots only when you need drill-down to individual lot rows.

-----------------------------------------------------------------------------------------------

+----------------------------------------------------------------------------------+
| Filters:  [Request Type] [Status] [Priority] [Executor] [Date range: Created At] |
+----------------------------------------------------------------------------------+
|  KPI Cards:  Total Requests | New | In Progress | Completed | Issue | Completed %|
|              Avg Cycle (hrs) | Avg Start Lag (hrs)*                                 |
+-----------------------------+----------------------------------+------------------+
|  Column/Stacked Bar         |  Line (Requests over time)       |  Donut by Status |
|  Requests by Request Type   |  (Month: Created At)             |  (optional)      |
+-----------------------------+----------------------------------+------------------+
|                          Detail Table (v_requests_for_bi)                         |
|  ID | Request Type | Status | Executor | Created | Started | Completed | Lots |  |
|  SLA Flags* | Cycle Time (hrs) | Sampling Lots | Project (if Sampling)           |
+----------------------------------------------------------------------------------+

* Optional: show a red/amber/green SLA chip based on your rules (e.g., “Completed in ≤48h”).

Fields to use (from the views you created)

Use v_requests_for_bi for nearly everything:
id, request_type, task_priority, status, executor, created_at, started_at, completed_at, qr_date, lots_count, sampling_lots_count, cycle_time_hours

When you need per-lot drilldown, relate lots and sampling_lots to v_requests_for_bi via request_id = id.

How the executor updates status (two common paths)
Option A — Power BI (Power Apps button inside the report)

This keeps your BI as the single place to view + update.

1) Add the Power Apps visual

In Power BI Desktop: Insert → Power Apps.

Add fields to the visual’s “Data” well:
id, status, executor (and maybe request_type for context).

Click Create new (or choose an existing app). Power BI passes these fields to Power Apps as a table called PowerBIIntegration.Data.

2) Build a tiny form in Power Apps

Inside the generated app:

Add a Gallery or Data table bound to PowerBIIntegration.Data.
Items = PowerBIIntegration.Data

Add:

A dropdown ddStatus with items: ["New","In Progress","Completed","Issue"]

A TextInput txtNote for notes

A Button btnUpdate labeled “Update Status”

3) Connect to your API (via Power Automate)

Easiest & secure route:

In Power Apps, Insert → Power Automate and create a new flow UpdateRequestStatus.

In the flow:

Trigger: “Power Apps”

Compose or Initialize variables for id, status, executor, note (coming from Power Apps).

HTTP action:

Method: PATCH

URI: https://YOUR_API_HOST/api/requests/@{triggerBody()['id']}/status

Headers: Content-Type: application/json

Body:

{
  "status": "@{triggerBody()['status']}",
  "executor": "@{triggerBody()['executor']}",
  "note": "@{triggerBody()['note']}"
}


Respond to Power Apps with the HTTP status code / message.

Back in Power Apps, set the button’s OnSelect:

// capture the current row from the gallery
Set(varRow, Gallery1.Selected);

// call the flow with selected values
Set(varResult,
    UpdateRequestStatus.Run(
        Text(varRow.id),
        ddStatus.Selected.Value,
        If(IsBlank(User().FullName), "Executor", User().FullName),
        txtNote.Text
    )
);

// give feedback and tell Power BI to refresh
If(
    !IsBlank(varResult),
    Notify("Status updated ✅", NotificationType.Success, 2000),
    Notify("Update failed ❌", NotificationType.Error, 3000)
);

// optional: clear inputs
Reset(txtNote);


Refresh behavior

If your Power BI model is DirectQuery, the visual refresh will reflect changes almost immediately.

If Import, either click Refresh or enable Page auto refresh (e.g., every 1–5 minutes).

4) Row-level control (who can update)

Limit app access to executors (Power Apps sharing).

On the API, verify the caller (e.g., an API key or gateway IP) and optionally enforce that only certain users can set Completed or Issue.

Option B — Tableau (Write-back extension)

If you’re in Tableau:

Install a write-back extension (e.g., Infotopics WriteBack, Kinesis Labs Write-Back, etc.) or use a simple URL action that opens a tiny internal web form.

Bind selection to the extension so the selected id flows into a small form with:

Status dropdown: New / In Progress / Completed / Issue

Note

Update button that calls PATCH /api/requests/:id/status

Live view: Use a Live connection, or refresh extract after update.

Nice touches for the dashboard

Status chips (conditional formatting):

New = gray

In Progress = blue

Completed = green

Issue = red

SLA indicator (DAX example in Power BI):

SLA Breached = 
VAR Cutoff = 48    -- hours
RETURN IF(
    'v_requests_for_bi'[status] = "Completed" 
    && 'v_requests_for_bi'[cycle_time_hours] > Cutoff,
    "Breached", "OK"
)


Then color the cell: “Breached” = red, “OK” = green.

Drill-through: right-click a request in the table → Drill-through page with all lots (lots for LT/Shipment/Scrap or sampling_lots for Sampling).

Executor leaderboard: bar chart Completed by executor (last 30/90 days).

End-to-end flow (what the executor actually does)

Open the dashboard → filter to their site / request type.

Click a row (the request they’re working on).

In the embedded app (Power Apps in PBI / write-back panel in Tableau):

Set Status to “In Progress”, add a quick note → Update.

When done, set to Completed with a closing note → Update.

The cards and charts update to show the new counts/state (DirectQuery: live; Import: on refresh/interval).

----------------------------------------------------------------------------------

Perfect—here’s a crisp, step-by-step for **Option A (Power BI + Power Apps visual)** so executors can update request status via your `PATCH /api/requests/:id/status` API.

---

# A) Prep (once)

1. **API reachable**: Your Node server already has `cors()`—make sure it’s reachable from Power Apps (public URL or via your org’s network/VPN).
2. **Data model ready** in Power BI: connect to MySQL and include at least:

   * `v_requests_for_bi` (fields: `id, request_type, status, executor, created_at, completed_at, cycle_time_hours`…)
   * (Optional) `request_status_history`, `lots`, `sampling_lots`.
3. Prefer **DirectQuery** for near-instant updates; if using **Import**, enable **Page refresh** (e.g., 1–5 min).

---

# B) Add a Power Apps visual inside Power BI

1. In **Power BI Desktop**, go to your report page → **Insert → Power Apps**.
2. In the **Power Apps visual** “Data” well, add these fields from `v_requests_for_bi`:

   * `id`, `status`, `executor`, `request_type` (and any others you want visible).
3. Click **Create new** (opens Power Apps Studio pre-wired to your report).

---

# C) Build the tiny Power App (2–3 minutes)

1. **Gallery**:

   * Select the auto-added gallery.
   * Set `Items = PowerBIIntegration.Data` (usually set by default).
   * Show `ThisItem.id`, `ThisItem.status`, `ThisItem.executor` in the template.
2. **Controls**:

   * Insert a **Dropdown** `ddStatus` → `Items = ["New","In Progress","Completed","Issue"]`, and `Default = ThisItem.status`.
   * Insert a **TextInput** `txtNote` (Hint: `HintText = "Optional note"`).
   * (Optional) **TextInput** `txtExecutor` → `Default = User().FullName`.
   * Insert a **Button** `btnUpdate` → Text: “Update Status”.

You now have UI but need the button to call your API. Easiest path: a **Power Automate** flow.

---

# D) Create the Power Automate flow (called from the app)

1. In Power Apps Studio: **Insert → Power Automate → Create new flow**. Name it `UpdateRequestStatus`.
2. **Trigger**: “Power Apps (V2)”.
3. Click **+ Add an input** four times:

   * `id` (Text)
   * `status` (Text)
   * `executor` (Text)
   * `note` (Text)
4. **HTTP** action (Premium):

   * Method: `PATCH`
   * URI (Expression):

     ```
     concat('https://YOUR_API_HOST/api/requests/', triggerBody()['id'], '/status')
     ```
   * Headers:

     ```
     Content-Type: application/json
     ```

     (Optional) add `x-api-key: YOUR_SECRET` if you secure the API.
   * Body:

     ```json
     {
       "status": "@{triggerBody()['status']}",
       "executor": "@{triggerBody()['executor']}",
       "note": "@{triggerBody()['note']}"
     }
     ```
5. **Respond to Power Apps**: add **“Respond to a PowerApp or flow”** → add output “message” (Text) with e.g. `Status updated`.
6. **Save** the flow.

> Licensing note: the HTTP action is a **Premium** connector. If you can’t use Premium, create a **Custom Connector** (also Premium) or host a tiny Azure Function/API that you call via a standard connector. If Premium isn’t available at all, consider updating status in your own small React “Status Console” page instead of inside Power BI.

---

# E) Wire the flow to your button

Back in Power Apps (the app you left open):

1. **Insert → Power Automate** → pick `UpdateRequestStatus`. This adds a function `UpdateRequestStatus.Run(...)`.
2. Set the **button’s OnSelect**:

   ```powerapps
   Set(varRow, Gallery1.Selected);
   Set(_result,
       UpdateRequestStatus.Run(
           Text(varRow.id),
           ddStatus.Selected.Value,
           If(IsBlank(txtExecutor.Text), User().FullName, txtExecutor.Text),
           txtNote.Text
       )
   );
   Notify("Status updated ✅", NotificationType.Success, 2000);
   Reset(txtNote);
   ```
3. **File → Save**, **Publish** the app, then close to return to Power BI Desktop. The Power Apps visual will now show your app.

---

# F) Use it in Power BI

1. In the **table** or **Power Apps visual’s gallery**, select the request row.
2. Choose a **Status** in `ddStatus`, add a note (optional), press **Update**.
3. The flow calls your Node API (`PATCH /api/requests/:id/status`).

   * Backend:

     * Updates `requests.status` (+ timestamps/issue\_note as per your code).
     * Inserts a row into `request_status_history`.
4. **See it update**:

   * **DirectQuery**: visuals update almost immediately on interaction/requery.
   * **Import**: click **Refresh** or rely on **Page refresh**.

---

# G) (Optional) Secure the API quickly

Add a simple shared secret in your server for the PATCH route:

```ts
// before the route
const API_KEY = process.env.API_KEY;

app.patch("/api/requests/:id/status", (req, res, next) => {
  if (API_KEY && req.headers["x-api-key"] !== API_KEY) {
    return res.status(401).json({ message: "Unauthorized" });
  }
  return next();
}, async (req, res) => {
  // ...existing handler...
});
```

Then in the Flow’s HTTP action, add header `x-api-key: <same secret>`.

---

# H) Quick test checklist

* Run a Sampling + a Shipment request so you have data.
* In the report, filter to one **Request Type** and pick a row.
* Update to **In Progress** → confirm `started_at` got set in DB.
* Update to **Completed** → confirm `completed_at` set and KPI cards change.
* Set **Issue** with a note → check `issue_note` and history table.

That’s it—your Power BI report is now both a live **monitor** and a lightweight **work console** for executors.
